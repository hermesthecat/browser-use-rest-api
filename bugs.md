# Bug Raporu ve Ã‡Ã¶zÃ¼m Ã–nerileri

Bu dokÃ¼manda AI Assistant API projesinde tespit edilen potansiyel bug'lar, gÃ¼venlik aÃ§Ä±klarÄ± ve iyileÅŸtirme Ã¶nerileri detaylandÄ±rÄ±lmÄ±ÅŸtÄ±r.

## ðŸ”´ Kritik Bug'lar

### 1. Eksik Environment Variable KontrolÃ¼
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 37-40, 169-171)
**Sorun:** 
- `GOOGLE_API_KEY` boÅŸ veya None olabilir
- `GOOGLE_MODEL_NAME` boÅŸ olabilir  
- `SERVER_HOST` ve `SERVER_PORT` None olabilir
- Uygulama Ã§alÄ±ÅŸma zamanÄ±nda hata verebilir

**Risk Seviyesi:** YÃ¼ksek
**Etki:** Uygulama baÅŸlatÄ±lamaz veya Ã§alÄ±ÅŸma zamanÄ±nda beklenmedik hatalar

**Ã‡Ã¶zÃ¼m:**
```python
# Environment variable validation
import sys

def validate_environment():
    required_env_vars = {
        'GOOGLE_API_KEY': os.getenv('GOOGLE_API_KEY'),
        'GOOGLE_MODEL_NAME': os.getenv('GOOGLE_MODEL_NAME'),
        'SERVER_HOST': os.getenv('SERVER_HOST'),
        'SERVER_PORT': os.getenv('SERVER_PORT')
    }

    for var_name, var_value in required_env_vars.items():
        if not var_value:
            print(f"ERROR: Required environment variable {var_name} is not set")
            sys.exit(1)

    # Port validation
    try:
        port = int(os.getenv('SERVER_PORT'))
        if port < 1 or port > 65535:
            print("ERROR: SERVER_PORT must be between 1 and 65535")
            sys.exit(1)
    except (ValueError, TypeError):
        print("ERROR: SERVER_PORT must be a valid integer")
        sys.exit(1)

# Uygulama baÅŸlangÄ±cÄ±nda Ã§aÄŸÄ±r
validate_environment()
```

### 2. Browser Context Kaynak SÄ±zÄ±ntÄ±sÄ±
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 100-101)
**Sorun:** 
- Browser instance ve context global olarak oluÅŸturuluyor
- Her request'te yeni Agent oluÅŸturuluyor ama browser context kapatÄ±lmÄ±yor
- Bellek sÄ±zÄ±ntÄ±sÄ± ve kaynak tÃ¼kenmesi riski

**Risk Seviyesi:** YÃ¼ksek
**Etki:** Bellek sÄ±zÄ±ntÄ±sÄ±, performans dÃ¼ÅŸÃ¼klÃ¼ÄŸÃ¼, sistem Ã§Ã¶kmesi

**Ã‡Ã¶zÃ¼m:**
```python
# Global browser instance'larÄ± kaldÄ±r ve her request iÃ§in yeni oluÅŸtur
@app.post("/ask", response_model=Answer)
async def ask_question(question: Question):
    browser_instance = None
    context = None
    try:
        # Her request iÃ§in yeni browser instance oluÅŸtur
        browser_instance = browser.Browser(config=browser_config)
        context = BrowserContext(browser=browser_instance, config=context_config)
        
        agent = Agent(
            browser_context=context,
            task=question.task,
            llm=llm,
            controller=controller,
            system_prompt_class=MySystemPrompt
        )
        
        history = await agent.run()
        # ... rest of the code
        
    finally:
        # KaynaklarÄ± temizle
        if context:
            try:
                await context.close()
            except Exception as e:
                print(f"Error closing context: {e}")
        if browser_instance:
            try:
                await browser_instance.close()
            except Exception as e:
                print(f"Error closing browser: {e}")
```

### 3. Hardcoded IP Adresi
**Dosya:** `index.html` (SatÄ±r 93)
**Sorun:** 
- API URL'si hardcoded: `http://10.11.13.14:8000/ask`
- FarklÄ± ortamlarda Ã§alÄ±ÅŸmaz
- GÃ¼venlik riski (internal IP exposed)

**Risk Seviyesi:** YÃ¼ksek
**Etki:** Portability sorunu, gÃ¼venlik riski

**Ã‡Ã¶zÃ¼m:**
```javascript
// Dinamik API URL belirleme
function getApiUrl() {
    // Ã–nce environment variable kontrol et
    if (window.API_BASE_URL) {
        return window.API_BASE_URL + '/ask';
    }
    
    // Sonra current host kullan
    const protocol = window.location.protocol;
    const hostname = window.location.hostname;
    const port = window.location.port || (protocol === 'https:' ? '443' : '80');
    
    // Development iÃ§in localhost kontrolÃ¼
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return `${protocol}//${hostname}:8000/ask`;
    }
    
    // Production iÃ§in same origin
    return `${protocol}//${hostname}:${port}/ask`;
}

$.ajax({
    url: getApiUrl(),
    // ... rest of the code
});
```

### 4. Async/Await Hata YÃ¶netimi
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 115-116)
**Sorun:** 
- `await agent.run()` Ã§aÄŸrÄ±sÄ±nda timeout yok
- Uzun sÃ¼ren iÅŸlemler sistem donmasÄ±na sebep olabilir
- Browser iÅŸlemleri sÄ±rasÄ±nda hata olursa kaynak temizliÄŸi yapÄ±lmÄ±yor

**Risk Seviyesi:** YÃ¼ksek
**Etki:** Sistem donmasÄ±, kaynak tÃ¼kenmesi

**Ã‡Ã¶zÃ¼m:**
```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def browser_context_manager():
    browser_instance = None
    context = None
    try:
        browser_instance = browser.Browser(config=browser_config)
        context = BrowserContext(browser=browser_instance, config=context_config)
        yield context
    finally:
        if context:
            await context.close()
        if browser_instance:
            await browser_instance.close()

@app.post("/ask", response_model=Answer)
async def ask_question(question: Question):
    try:
        async with browser_context_manager() as context:
            agent = Agent(
                browser_context=context,
                task=question.task,
                llm=llm,
                controller=controller,
                system_prompt_class=MySystemPrompt
            )
            
            # Timeout ile agent Ã§alÄ±ÅŸtÄ±r
            history = await asyncio.wait_for(
                agent.run(), 
                timeout=300.0  # 5 dakika timeout
            )
            
            # ... rest of the code
            
    except asyncio.TimeoutError:
        return JSONResponse(
            status_code=408,
            content={
                "error": "timeout",
                "message": "Ä°ÅŸlem zaman aÅŸÄ±mÄ±na uÄŸradÄ±"
            }
        )
```

## ðŸŸ¡ GÃ¼venlik AÃ§Ä±klarÄ±

### 5. CORS Wildcard KonfigÃ¼rasyonu
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 30)
**Sorun:** 
- `allow_origins=["*"]` tÃ¼m domainlere izin veriyor
- Production ortamÄ±nda gÃ¼venlik riski

**Risk Seviyesi:** Orta
**Etki:** Cross-origin saldÄ±rÄ±larÄ±, unauthorized access

**Ã‡Ã¶zÃ¼m:**
```python
# Environment'a gÃ¶re CORS ayarlarÄ±
def get_allowed_origins():
    origins_env = os.getenv('ALLOWED_ORIGINS', '')
    if origins_env:
        return [origin.strip() for origin in origins_env.split(',')]
    
    # Development iÃ§in default deÄŸerler
    return [
        "http://localhost:3000",
        "http://localhost:8080",
        "http://127.0.0.1:3000",
        "http://127.0.0.1:8080"
    ]

app.add_middleware(
    CORSMiddleware,
    allow_origins=get_allowed_origins(),
    allow_credentials=True,
    allow_methods=["GET", "POST"],  # Sadece gerekli methodlar
    allow_headers=["Content-Type", "Authorization"],  # Sadece gerekli headerlar
)
```

### 6. Browser Security Disabled
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 88-89)
**Sorun:** 
- `disable_security=True` browser gÃ¼venlik Ã¶zelliklerini kapatÄ±yor
- Potansiyel gÃ¼venlik riski

**Risk Seviyesi:** Orta
**Etki:** Browser tabanlÄ± gÃ¼venlik aÃ§Ä±klarÄ±

**Ã‡Ã¶zÃ¼m:**
```python
browser_config = BrowserConfig(
    headless=os.getenv('BROWSER_HEADLESS', 'true').lower() == 'true',
    disable_security=False,  # GÃ¼venliÄŸi aktif tut
    # Gerekirse spesifik gÃ¼venlik ayarlarÄ± ekle
    extra_chromium_args=[
        '--no-sandbox',  # Sadece container ortamÄ±nda
        '--disable-dev-shm-usage',
        '--disable-gpu'
    ] if os.getenv('CONTAINER_ENV') == 'true' else []
)
```

### 7. API Key Exposure Risk
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 40)
**Sorun:** 
- API key doÄŸrudan environment'tan alÄ±nÄ±yor
- Hata mesajlarÄ±nda expose olabilir
- Logging'de gÃ¶rÃ¼nebilir

**Risk Seviyesi:** Orta
**Etki:** API key sÄ±zÄ±ntÄ±sÄ±

**Ã‡Ã¶zÃ¼m:**
```python
from pydantic import SecretStr

class Config:
    def __init__(self):
        self.google_api_key = SecretStr(os.getenv('GOOGLE_API_KEY', ''))
        self.google_model_name = os.getenv('GOOGLE_MODEL_NAME', 'gemini-2.0-flash-exp')
        
    def get_api_key(self) -> str:
        if not self.google_api_key.get_secret_value():
            raise ValueError("GOOGLE_API_KEY is required")
        return self.google_api_key.get_secret_value()

config = Config()

# Initialize the model
llm = ChatGoogleGenerativeAI(
    model=config.google_model_name,
    api_key=config.get_api_key()
)
```

## ðŸŸ  Hata YÃ¶netimi SorunlarÄ±

### 8. Generic Exception Handling
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 156-163)
**Sorun:** 
- TÃ¼m exception'lar generic olarak yakalanÄ±yor
- Hata tÃ¼rÃ¼ belirsiz, debugging zorlaÅŸÄ±yor
- Sensitive bilgi sÄ±zÄ±ntÄ±sÄ± riski

**Risk Seviyesi:** Orta
**Etki:** Debugging zorluÄŸu, gÃ¼venlik riski

**Ã‡Ã¶zÃ¼m:**
```python
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)

class APIError(Exception):
    def __init__(self, message: str, status_code: int = 500, error_code: str = "internal_error"):
        self.message = message
        self.status_code = status_code
        self.error_code = error_code
        super().__init__(message)

@app.post("/ask", response_model=Answer)
async def ask_question(question: Question):
    try:
        # ... existing code
    except ValueError as e:
        logger.error(f"Validation error: {str(e)}")
        raise APIError("Invalid input parameters", 400, "validation_error")
    except asyncio.TimeoutError:
        logger.error("Request timeout")
        raise APIError("Request timed out", 408, "timeout")
    except ConnectionError as e:
        logger.error(f"Connection error: {str(e)}")
        raise APIError("External service unavailable", 503, "service_unavailable")
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}", exc_info=True)
        raise APIError("An unexpected error occurred", 500, "internal_server_error")

@app.exception_handler(APIError)
async def api_error_handler(request, exc: APIError):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.error_code,
            "message": exc.message
        }
    )
```

### 9. Eksik Input Validation
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 46)
**Sorun:** 
- Question.task iÃ§in length kontrolÃ¼ yok
- Empty string kontrolÃ¼ yok
- Malicious input korumasÄ± yok

**Risk Seviyesi:** Orta
**Etki:** DoS saldÄ±rÄ±larÄ±, sistem yavaÅŸlamasÄ±

**Ã‡Ã¶zÃ¼m:**
```python
from pydantic import BaseModel, validator, Field
import re

class Question(BaseModel):
    task: str = Field(..., min_length=1, max_length=5000)
    
    @validator('task')
    def validate_task(cls, v):
        if not v or not v.strip():
            raise ValueError('Task cannot be empty')
        
        # Malicious pattern kontrolÃ¼
        malicious_patterns = [
            r'<script.*?>.*?</script>',  # XSS
            r'javascript:',
            r'data:text/html',
            r'vbscript:',
        ]
        
        for pattern in malicious_patterns:
            if re.search(pattern, v, re.IGNORECASE):
                raise ValueError('Invalid characters detected')
        
        return v.strip()
```

### 10. JSON Parsing HatalarÄ±
**Dosya:** `browser_use_rest_api.py` (SatÄ±r 140)
**Sorun:** 
- `Answer.model_validate_json(result)` baÅŸarÄ±sÄ±z olabilir
- Result None veya invalid JSON olabilir

**Risk Seviyesi:** Orta
**Etki:** Uygulama Ã§Ã¶kmesi, hatalÄ± yanÄ±tlar

**Ã‡Ã¶zÃ¼m:**
```python
@app.post("/ask", response_model=Answer)
async def ask_question(question: Question):
    try:
        # ... existing code
        
        # Final sonucu al
        result = history.final_result()
        if not result:
            raise APIError("No result found", 404, "not_found")
            
        # Sonucu JSON'a Ã§evir
        try:
            # Ã–nce string kontrolÃ¼
            if not isinstance(result, str):
                result = str(result)
                
            # JSON validation
            import json
            json.loads(result)  # JSON geÃ§erliliÄŸi kontrol et
            
            answer = Answer.model_validate_json(result)
            return JSONResponse(
                status_code=200,
                content={
                    "answer": answer.answer
                }
            )
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON result: {result[:100]}...")
            raise APIError("Invalid response format", 500, "parse_error")
        except Exception as e:
            logger.error(f"Result parsing error: {str(e)}")
            raise APIError("Failed to parse result", 500, "parse_error")
            
    except APIError:
        raise
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}", exc_info=True)
        raise APIError("Internal server error", 500, "internal_server_error")
```

## ðŸ”µ Performans ve Stabilite SorunlarÄ±

### 11. Memory Leak Riski
**Dosya:** `browser_use_rest_api.py` (Global scope)
**Sorun:** 
- Global browser instance sÃ¼rekli aÃ§Ä±k kalÄ±yor
- Agent instance'larÄ± temizlenmiyor
- Memory usage sÃ¼rekli artabilir

**Risk Seviyesi:** YÃ¼ksek
**Etki:** Bellek tÃ¼kenmesi, sistem Ã§Ã¶kmesi

**Ã‡Ã¶zÃ¼m:**
```python
import gc
from contextlib import asynccontextmanager

class BrowserManager:
    def __init__(self):
        self.browser_config = BrowserConfig(
            headless=os.getenv('BROWSER_HEADLESS', 'true').lower() == 'true',
            disable_security=False
        )
        self.context_config = BrowserContextConfig(
            wait_for_network_idle_page_load_time=3.0,
            browser_window_size={'width': 1280, 'height': 1100},
            locale='en-US',
            highlight_elements=True,
            viewport_expansion=500
        )
    
    @asynccontextmanager
    async def get_context(self):
        browser_instance = None
        context = None
        try:
            browser_instance = browser.Browser(config=self.browser_config)
            context = BrowserContext(browser=browser_instance, config=self.context_config)
            yield context
        finally:
            if context:
                await context.close()
            if browser_instance:
                await browser_instance.close()
            gc.collect()  # Force garbage collection

browser_manager = BrowserManager()
```

### 12. Concurrent Request Handling
**Dosya:** `browser_use_rest_api.py`
**Sorun:** 
- Concurrent request'ler iÃ§in browser resource management yok
- AynÄ± anda Ã§ok fazla browser instance aÃ§Ä±labilir
- System resource exhaustion riski

**Risk Seviyesi:** Orta
**Etki:** Sistem yavaÅŸlamasÄ±, resource exhaustion

**Ã‡Ã¶zÃ¼m:**
```python
import asyncio
from asyncio import Semaphore

# Maximum concurrent browser instances
MAX_CONCURRENT_BROWSERS = int(os.getenv('MAX_CONCURRENT_BROWSERS', '3'))
browser_semaphore = Semaphore(MAX_CONCURRENT_BROWSERS)

@app.post("/ask", response_model=Answer)
async def ask_question(question: Question):
    async with browser_semaphore:
        try:
            async with browser_manager.get_context() as context:
                # ... rest of the code
                pass
        except Exception as e:
            logger.error(f"Error in ask_question: {str(e)}")
            raise APIError("Service temporarily unavailable", 503, "service_unavailable")
```

## ðŸŸ¢ KonfigÃ¼rasyon ve Deployment SorunlarÄ±

### 13. Service User Privileges
**Dosya:** `ai-assistant.service` (SatÄ±r 6)
**Sorun:** 
- Service root user ile Ã§alÄ±ÅŸÄ±yor
- GÃ¼venlik riski
- Principle of least privilege ihlali

**Risk Seviyesi:** Orta
**Etki:** GÃ¼venlik riski, sistem compromise

**Ã‡Ã¶zÃ¼m:**
```bash
# Dedicated user oluÅŸtur
sudo useradd -r -s /bin/false ai-assistant
sudo mkdir -p /opt/ai-assistant
sudo chown ai-assistant:ai-assistant /opt/ai-assistant

# Service file gÃ¼ncelle
[Service]
Type=simple
User=ai-assistant
Group=ai-assistant
WorkingDirectory=/opt/ai-assistant
Environment=PYTHONPATH=/opt/ai-assistant/venv/bin/python
ExecStart=/opt/ai-assistant/venv/bin/python /opt/ai-assistant/browser_use_rest_api.py
Restart=always
RestartSec=3
```

### 14. Missing Dependencies Version Pinning
**Dosya:** `requirements.txt`
**Sorun:** 
- Version pinning yok
- Dependency conflict riski
- Reproducible builds zorlaÅŸÄ±yor

**Risk Seviyesi:** DÃ¼ÅŸÃ¼k
**Etki:** Deployment sorunlarÄ±, version conflicts

**Ã‡Ã¶zÃ¼m:**
```txt
browser-use==0.1.0
google-generativeai==0.3.2
langchain-google-genai==0.0.8
pydantic==2.5.0
pyperclip==1.8.2
gradio==4.8.0
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-dotenv==1.0.0
```

### 15. Windows Service Path Issues
**Dosya:** `install_windows_service.ps1` (SatÄ±r 84)
**Sorun:** 
- PATH environment variable yanlÄ±ÅŸ set ediliyor
- Service baÅŸlatma sorunlarÄ± olabilir

**Risk Seviyesi:** DÃ¼ÅŸÃ¼k
**Etki:** Service baÅŸlatma hatasÄ±

**Ã‡Ã¶zÃ¼m:**
```powershell
# DoÄŸru PATH ayarÄ±
$currentPath = [Environment]::GetEnvironmentVariable("PATH", "Machine")
$pythonDir = Split-Path -Parent $pythonPath
$newPath = "$pythonDir;$scriptDir;$currentPath"
& $nssmExe set $serviceName AppEnvironmentExtra "PATH=$newPath"
```

### 16. Logging Configuration Eksik
**Dosya:** TÃ¼m proje
**Sorun:** 
- Structured logging yok
- Log rotation yok
- Debug bilgileri yetersiz

**Risk Seviyesi:** DÃ¼ÅŸÃ¼k
**Etki:** Debugging zorluÄŸu, disk space sorunlarÄ±

**Ã‡Ã¶zÃ¼m:**
```python
import logging
import logging.handlers
import sys
import os

def setup_logging():
    # Log directory oluÅŸtur
    log_dir = os.path.join(os.getcwd(), 'logs')
    os.makedirs(log_dir, exist_ok=True)
    
    # Formatter
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Root logger
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # File handler with rotation
    file_handler = logging.handlers.RotatingFileHandler(
        os.path.join(log_dir, 'app.log'),
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # Error file handler
    error_handler = logging.handlers.RotatingFileHandler(
        os.path.join(log_dir, 'error.log'),
        maxBytes=10*1024*1024,
        backupCount=5
    )
    error_handler.setLevel(logging.ERROR)
    error_handler.setFormatter(formatter)
    logger.addHandler(error_handler)

# Uygulama baÅŸlangÄ±cÄ±nda Ã§aÄŸÄ±r
setup_logging()
```

## ðŸ“‹ Ã–ncelik SÄ±ralamasÄ±

### ðŸ”´ Kritik (Hemen Ã§Ã¶zÃ¼lmeli):
1. Environment variable kontrolÃ¼
2. Browser context kaynak sÄ±zÄ±ntÄ±sÄ±
3. Hardcoded IP adresi
4. Async/await hata yÃ¶netimi

### ðŸŸ¡ YÃ¼ksek (1 hafta iÃ§inde):
5. CORS konfigÃ¼rasyonu
6. Input validation
7. Memory leak riski
8. API key exposure

### ðŸŸ  Orta (2 hafta iÃ§inde):
9. Exception handling iyileÅŸtirme
10. JSON parsing hatalarÄ±
11. Concurrent request handling
12. Browser security settings

### ðŸŸ¢ DÃ¼ÅŸÃ¼k (1 ay iÃ§inde):
13. Service user privileges
14. Dependency versioning
15. Windows service path dÃ¼zeltme
16. Logging configuration

## ðŸ”§ Genel Ä°yileÅŸtirme Ã–nerileri

### 1. Health Check Endpoint
```python
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "version": "1.0.0"
    }
```

### 2. Rate Limiting
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.post("/ask")
@limiter.limit("5/minute")
async def ask_question(request: Request, question: Question):
    # ... existing code
```

### 3. Configuration Management
```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    google_api_key: str
    google_model_name: str = "gemini-2.0-flash-exp"
    server_host: str = "0.0.0.0"
    server_port: int = 8000
    browser_headless: bool = True
    max_concurrent_browsers: int = 3
    allowed_origins: str = "http://localhost:3000"
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### 4. Monitoring ve Metrics
```python
from prometheus_client import Counter, Histogram, generate_latest

REQUEST_COUNT = Counter('requests_total', 'Total requests', ['method', 'endpoint'])
REQUEST_DURATION = Histogram('request_duration_seconds', 'Request duration')

@app.middleware("http")
async def add_metrics(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    duration = time.time() - start_time
    
    REQUEST_COUNT.labels(method=request.method, endpoint=request.url.path).inc()
    REQUEST_DURATION.observe(duration)
    
    return response

@app.get("/metrics")
async def metrics():
    return Response(generate_latest(), media_type="text/plain")
```

Bu bug'larÄ±n Ã§Ã¶zÃ¼mÃ¼ sistem gÃ¼venliÄŸini, performansÄ±nÄ± ve stabilitesini Ã¶nemli Ã¶lÃ§Ã¼de artÄ±racaktÄ±r. Ã–ncelikli olarak kritik bug'lardan baÅŸlanmasÄ± Ã¶nerilir.